/**
 * This Firestore Security Ruleset establishes a secure access model for the VolunteerConnect platform.
 *
 * Core Philosophy:
 * The rules enforce a mixed security model. Public data, like project listings, is
 * readable by anyone. User-specific data, such as a volunteer's private profile, is strictly
 * confined to the owning user. Writes are restricted to owners.
 *
 * Data Structure:
 * - /users/{userId}/volunteerProfile/{profileId}: Private data for a specific volunteer.
 * - /projects/{projectId}: Publicly readable project listings, owned by users.
 * - /projectVolunteers/{projectVolunteerId}: Represents the link (application) between a volunteer and a project.
 * - /chats/{chatId}/messages/{messageId}: Private messages between participants of a chat.
 *
 * Key Security Decisions:
 * - Public Projects: Projects are public-read, but writes are restricted to the user who created it,
 *   identified by the `creatorId` field in the project document.
 * - Chat Security: Access to chat messages is secured by a parent /chats/{chatId} document,
 *   which is assumed to contain a `participantIds` array. This allows rules to efficiently check
 *   if a user is part of a conversation without inspecting every message.
 * - Immutable References: Once created, key relational identifiers like `creatorId` on a project
 *   or `volunteerId` on an application are made immutable to maintain data integrity.
 *
 * Denormalization for Authorization:
 * The ruleset relies on denormalized data for efficient and secure authorization checks, avoiding
 * complex and costly multi-document reads.
 * - Project Ownership: Each `/projects` document must contain a `creatorId` field, directly
 *   linking it to its owner and simplifying write validation.
 * - Chat Participation: Subcollection rules for `/chats/{chatId}/messages` depend on a
 *   `participantIds` array on the parent `/chats/{chatId}` document.
 *
 * Structural Segregation:
 * Private volunteer data is stored in a dedicated subcollection `/users/{userId}/volunteerProfile`,
 * completely separating it from public data and ensuring its privacy through path-based security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if a document currently exists.
     * CRITICAL for all update and delete operations to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the authenticated user is the creator of a resource.
     * Assumes the resource data contains a `creatorId` field.
     */
    function isCreator(data) {
      return isSignedIn() && request.auth.uid == data.creatorId;
    }

    /**
     * Checks if the authenticated user is a participant in a given chat.
     * ASSUMPTION: This function assumes the /chats/{chatId} document contains
     * an array field named `participantIds`.
     */
    function isChatParticipant(chatId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds;
    }

    // --------------------------------------------------------------------
    // User Data (/users)
    // --------------------------------------------------------------------

    match /users/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if false;
    }

    match /users/{userId}/volunteerProfile/{profileId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    // --------------------------------------------------------------------
    // Project Data (/projects)
    // --------------------------------------------------------------------
    /**
     * @description Manages public project listings, which are owned by users.
     * @path /projects/{projectId}
     * @allow A logged-in user creating a new project: auth.uid = 'user123', (create) /projects/proj_abc with data { creatorId: 'user123', ... }
     * @deny A user who is not the creator trying to update a project: (update) /projects/proj_abc
     * @principle Enforces document ownership for writes via the `creatorId` field, while allowing public reads.
     */
    match /projects/{projectId} {
      allow get, list: if true;
      allow create: if isCreator(request.resource.data);
      allow update: if isExistingDoc() && isCreator(resource.data) && request.resource.data.creatorId == resource.data.creatorId;
      allow delete: if isExistingDoc() && isCreator(resource.data);
    }


    // --------------------------------------------------------------------
    // Relational & Collaborative Data (/projectVolunteers, /chats)
    // --------------------------------------------------------------------

    /**
     * @description Controls the link between a volunteer and a project they apply for.
     * @path /projectVolunteers/{projectVolunteerId}
     * @allow A volunteer creating an application for themselves: auth.uid = 'user_abc', (create) /projectVolunteers/pv_123 with data { volunteerId: 'user_abc', ... }
     * @deny A volunteer trying to read another volunteer's application: auth.uid = 'user_xyz', (get) /projectVolunteers/pv_123 where volunteerId is 'user_abc'.
     * @principle Access is granted only to the involved parties: the volunteer and the non-profit that owns the project.
     */
    match /projectVolunteers/{projectVolunteerId} {
      allow get: if isOwner(resource.data.volunteerId) || isCreator(get(/databases/$(database)/documents/projects/$(resource.data.projectId)).data);
      allow list: if request.auth != null && request.query.where[0][0] == 'volunteerId' && request.query.where[0][2] == request.auth.uid;
      allow create: if isSignedIn() && request.resource.data.volunteerId == request.auth.uid;
      allow update: if false; // Applications are immutable; they can be created or deleted.
      allow delete: if isExistingDoc() && (isOwner(resource.data.volunteerId) || isCreator(get(/databases/$(database)/documents/projects/$(resource.data.projectId)).data));
    }

    /**
     * @description Secures the chat container document.
     * @path /chats/{chatId}
     * @allow A chat participant reading the chat metadata: auth.uid is in chatDoc.participantIds, (get) /chats/chat_123
     * @deny A non-participant trying to read chat metadata: (get) /chats/chat_123
     * @principle Restricts access to chat metadata to only the designated participants.
     */
    match /chats/{chatId} {
      allow get: if isChatParticipant(chatId);
      allow list: if false; // Users should not be able to list all chats in the system.
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      allow update: if false; // For this prototype, participants cannot be changed.
      allow delete: if false;
    }

    /**
     * @description Secures messages within a a chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow A chat participant listing messages in their chat: auth.uid is in parent chatDoc.participantIds, (list) /chats/chat_123/messages
     * @deny A user trying to send a message to a chat they are not in: (create) /chats/chat_456/messages/msg_abc
     * @principle Subcollection access is governed by the parent document's `participantIds` list.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isChatParticipant(chatId);
      allow create: if isChatParticipant(chatId) && request.resource.data.senderId == request.auth.uid;
      allow update: if false; // Messages are immutable.
      allow delete: if isExistingDoc() && isChatParticipant(chatId) && isOwner(resource.data.senderId);
    }
  }
}
