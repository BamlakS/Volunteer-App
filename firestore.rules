/**
 * This Firestore Security Ruleset establishes a secure access model for the VolunteerConnect platform.
 *
 * Core Philosophy:
 * The rules enforce a mixed security model. Public data, like non-profit and project listings, is
 * readable by anyone. User-specific data, such as a volunteer's private profile, is strictly
 * confined to the owning user. Collaborative data, like project applications and chat messages,
 * is accessible only to the involved participants. The default security posture is to deny access.
 *
 * Data Structure:
 * - /users/{userId}/volunteerProfile/{profileId}: Private data for a specific volunteer.
 * - /nonProfits/{nonProfitId}: Publicly readable profiles for non-profit organizations.
 * - /projects/{projectId}: Publicly readable project listings, owned by non-profits.
 * - /projectVolunteers/{projectVolunteerId}: Represents the link (application) between a volunteer and a project.
 * - /chats/{chatId}/messages/{messageId}: Private messages between participants of a chat.
 *
 * Key Security Decisions:
 * - Public vs. Private: A clear separation is maintained. Top-level collections like /projects
 *   and /nonProfits are for public consumption (read-only), while user-specific data is nested
 *   under /users/{userId} for strict ownership-based security.
 * - Non-Profit Ownership: Writes to /nonProfits and their associated /projects are restricted.
 *   These rules ASSUME that a NonProfit document contains an `adminUids` array field, which lists
 *   the user UIDs authorized to manage that non-profit. This is a critical assumption for write
 *   operations.
 * - Chat Security: Access to chat messages is secured by a parent /chats/{chatId} document,
 *   which is assumed to contain a `participantIds` array. This allows rules to efficiently check
 *   if a user is part of a conversation without inspecting every message.
 * - Immutable References: Once created, key relational identifiers like `nonProfitId` on a project
 *   or `volunteerId` on an application are made immutable to maintain data integrity.
 *
 * Denormalization for Authorization:
 * The ruleset relies on denormalized data for efficient and secure authorization checks, avoiding
 * complex and costly multi-document reads.
 * - Project Ownership: Each `/projects` document must contain a `nonProfitId` field, directly
 *   linking it to its owner and simplifying write validation.
 * - Chat Participation: Subcollection rules for `/chats/{chatId}/messages` depend on a
 *   `participantIds` array on the parent `/chats/{chatId}` document.
 *
 * Structural Segregation:
 * Private volunteer data is stored in a dedicated subcollection `/users/{userId}/volunteerProfile`,
 * completely separating it from public data and ensuring its privacy through path-based security.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if a document currently exists.
     * CRITICAL for all update and delete operations to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the authenticated user is an administrator for a given non-profit.
     * ASSUMPTION: This function assumes the /nonProfits/{nonProfitId} document
     * contains an array field named `adminUids` that lists the UIDs of its managers.
     */
    function isNonProfitAdmin(nonProfitId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/nonProfits/$(nonProfitId)).data.adminUids;
    }

    /**
     * Checks if the authenticated user is a participant in a given chat.
     * ASSUMPTION: This function assumes the /chats/{chatId} document contains
     * an array field named `participantIds`.
     */
    function isChatParticipant(chatId) {
      return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds;
    }

    // --------------------------------------------------------------------
    // User Data (/users)
    // --------------------------------------------------------------------

    /**
     * @description Controls access to a user's private data tree.
     * @path /users/{userId}
     * @allow A user creating their own user document for the first time: auth.uid = 'user_abc', (create) /users/user_abc
     * @deny An anonymous user trying to create a user document: auth = null, (create) /users/user_abc
     * @principle A user's root document can only be created by that user. No other reads or writes are allowed.
     */
    match /users/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secures a volunteer's private profile information.
     * @path /users/{userId}/volunteerProfile/{profileId}
     * @allow A user reading their own profile: auth.uid = 'user_abc', (get) /users/user_abc/volunteerProfile/profile_123
     * @deny A different user trying to update a profile: auth.uid = 'user_xyz', (update) /users/user_abc/volunteerProfile/profile_123
     * @principle Restricts all access to a user's own data tree, enforcing strict data privacy.
     */
    match /users/{userId}/volunteerProfile/{profileId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(userId) && isExistingDoc();
    }

    // --------------------------------------------------------------------
    // Non-Profit & Project Data (/nonProfits, /projects)
    // --------------------------------------------------------------------

    /**
     * @description Manages public profiles for non-profit organizations.
     * @path /nonProfits/{nonProfitId}
     * @allow Any user, signed in or not, reading a non-profit's profile: (get) /nonProfits/np_123
     * @deny Any user trying to create or modify a profile: (create) /nonProfits/np_456
     * @principle Data is public-read. Writes are disabled pending a clear ownership model.
     */
    match /nonProfits/{nonProfitId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'NonProfit' entity is missing an 'ownerId' or 'adminUids' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field (e.g., 'adminUids').
    }

    /**
     * @description Manages public project listings, which are owned by non-profits.
     * @path /projects/{projectId}
     * @allow An admin of 'np_123' creating a new project: auth.uid is in np_123.adminUids, (create) /projects/proj_abc with data { nonProfitId: 'np_123', ... }
     * @deny A user who is not an admin of 'np_123' trying to update a project: (update) /projects/proj_abc
     * @principle Enforces document ownership for writes via the `nonProfitId` field, while allowing public reads.
     */
    match /projects/{projectId} {
      allow get, list: if true;
      allow create: if isNonProfitAdmin(request.resource.data.nonProfitId);
      allow update: if isExistingDoc() && isNonProfitAdmin(resource.data.nonProfitId) && request.resource.data.nonProfitId == resource.data.nonProfitId;
      allow delete: if isExistingDoc() && isNonProfitAdmin(resource.data.nonProfitId);
    }

    // --------------------------------------------------------------------
    // Relational & Collaborative Data (/projectVolunteers, /chats)
    // --------------------------------------------------------------------

    /**
     * @description Controls the link between a volunteer and a project they apply for.
     * @path /projectVolunteers/{projectVolunteerId}
     * @allow A volunteer creating an application for themselves: auth.uid = 'user_abc', (create) /projectVolunteers/pv_123 with data { volunteerId: 'user_abc', ... }
     * @deny A volunteer trying to read another volunteer's application: auth.uid = 'user_xyz', (get) /projectVolunteers/pv_123 where volunteerId is 'user_abc'.
     * @principle Access is granted only to the involved parties: the volunteer and the non-profit that owns the project.
     */
    match /projectVolunteers/{projectVolunteerId} {
      allow get: if isOwner(resource.data.volunteerId) || isNonProfitAdmin(get(/databases/$(database)/documents/projects/$(resource.data.projectId)).data.nonProfitId);
      allow list: if false; // Disallow listing all applications for security.
      allow create: if isSignedIn() && request.resource.data.volunteerId == request.auth.uid;
      allow update: if false; // Applications are immutable; they can be created or deleted.
      allow delete: if isExistingDoc() && (isOwner(resource.data.volunteerId) || isNonProfitAdmin(get(/databases/$(database)/documents/projects/$(resource.data.projectId)).data.nonProfitId));
    }

    /**
     * @description Secures the chat container document.
     * @path /chats/{chatId}
     * @allow A chat participant reading the chat metadata: auth.uid is in chatDoc.participantIds, (get) /chats/chat_123
     * @deny A non-participant trying to read chat metadata: (get) /chats/chat_123
     * @principle Restricts access to chat metadata to only the designated participants.
     */
    match /chats/{chatId} {
      allow get: if isChatParticipant(chatId);
      allow list: if false; // Users should not be able to list all chats in the system.
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      allow update: if false; // For this prototype, participants cannot be changed.
      allow delete: if false;
    }

    /**
     * @description Secures messages within a chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow A chat participant listing messages in their chat: auth.uid is in parent chatDoc.participantIds, (list) /chats/chat_123/messages
     * @deny A user trying to send a message to a chat they are not in: (create) /chats/chat_456/messages/msg_abc
     * @principle Subcollection access is governed by the parent document's `participantIds` list.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isChatParticipant(chatId);
      allow create: if isChatParticipant(chatId) && request.resource.data.senderId == request.auth.uid;
      allow update: if false; // Messages are immutable.
      allow delete: if isExistingDoc() && isChatParticipant(chatId) && isOwner(resource.data.senderId);
    }
  }
}